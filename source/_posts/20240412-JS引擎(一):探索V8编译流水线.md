---
title: JS引擎（一）：探索V8编译流水线
tags:
  - JavaScript
  - Browser
  - Engine
categories:
  - JS引擎
---
## 解释型语言

JavaScript一直被称为解释型语言，即不经过编译的过程，直接在运行时由解释器将js源代码一句句翻译执行。但最近接触到JavaScript其实引入了**JIT（Just in Time）即时编译**，它会对代码进行一些优化，也可以做到生成并存储代码的编译版本。

此外，JavaScript存在**变量提升**的特性——在作用域内任何var声明的变量都会被提升到顶部并且赋值为undefined。

如果JS是一个纯解释型语言，仅通过解释器逐行翻译源代码执行是怎样提前获取到作用域内部的变量声明，并提升到作用域顶部的呢？

要解释这个问题，就需要了解JS代码的处理过程。

### 机器语言 & 汇编语言 & 高级语言

当我们编写了一段JavaScript代码并试图运行它的时候，我们就产生了一个目标：告诉计算机要做什么。同时也产生了一个问题：计算机并不能读懂我们的语言。机器运行采用**机器语言**，它仅由“0”与“1”组成，即**用二进制代码表示的计算机能直接识别和执行的一种机器指指令系统令的集合**。

在我们常用的PC机中，有一个芯片，就是我们常说的**CPU（Central Processing Unit，中央处理单元）**可以执行机器指令，进行运算。但是由于硬件设计和内部结构的不同，每一种CPU需要用不同的电平脉冲来控制。因此每一种CPU都有自己的机器指令集，也就是机器语言。不同系统的机器语言不互通，例如在WIN上，“关机”的机器语言是“10011101010”，在MACOS上，“关机”的机器语言是“10011101101”（只是假设，不代表两个系统真实的机器语言），机器语言不具备跨设备使用的能力。

早期的程序设计均使用机器语言。程序员们将用0, 1数字编成的程序代码打在纸带或卡片上，1打孔，0不打孔，再将程序通过纸带机或卡片机输入计算机，进行运算。但直接书写机器语言显然是很不友好的，随便一个操作都要写一长串“1001101010111...”，复杂又难读。

由此产生了**汇编语言**——定义一些指令与“0”和“1”二进制编码串互相映射，相当于助记符，让二进制编码变成人容易理解的样子，比如“inc eax”这条指令的机器码为40，即“0100 0000”等等。在执行时，机器还是会把指令转化为二进制去执行，只是借助指令的方式让人们更易理解。

虽然汇编语言让我们不必使用一长串“0”“1”来表示操作了，但使用汇编，一个简单操作需要的指令编码还是非常多。因此，Java、C++、Python、JavaScript等**高级语言**产生了。它们更接近自然语言，让我们的编码过程变得简单。但高级语言是方便我们理解了，计算机要如何理解呢？

### 解释型与编译型

将高级语言翻译为机器语言，有两种方式：**解释**与**编译**。

解释
